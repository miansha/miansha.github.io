<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[缓存那些事]]></title>
    <url>%2F2019%2F06%2F13%2F%E7%BC%93%E5%AD%98%E9%82%A3%E4%BA%9B%E4%BA%8B.html</url>
    <content type="text"><![CDATA[什么是缓存雪崩？缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。一般有三种处理办法： 一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。 给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。 为 key 设置不同的缓存失效时间。 什么是缓存穿透?缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。 有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。 什么是缓存预热?缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！ 什么是缓存更新?缓存更新除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 种策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种： 定时去清理过期的缓存； 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。 什么是缓存降级?当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。 持续更新中…]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础那些事]]></title>
    <url>%2F2019%2F06%2F11%2FJava%20%E5%9F%BA%E7%A1%80%E9%82%A3%E4%BA%9B%E4%BA%8B.html</url>
    <content type="text"><![CDATA[重载和重写的区别重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。 String 和 StringBuffer、StringBuilder 的区别是什么？String 为什么是不可变的？可变性简单的来说：String 类中使用 final 关键字字符数组保存字符串，private final char value[]，所以 String 对象是不可变的。而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串 char[] value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。 StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。 AbstractStringBuilder.java 12345678abstract class AbstractStringBuilder implements Appendable, CharSequence &#123; char[] value; int count; AbstractStringBuilder() &#123; &#125; AbstractStringBuilder(int capacity) &#123; value = new char[capacity]; &#125; 线程安全性String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 性能每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 == 与 equals==：它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)equals()：它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 说明 String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 持续更新中…]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 那些事]]></title>
    <url>%2F2019%2F05%2F06%2FSpring-%E9%82%A3%E4%BA%9B%E4%BA%8B.html</url>
    <content type="text"><![CDATA[谈谈你对 Spring 的理解？Spring 是发展至今已然形成了一个十分庞大的体系，具体可以访问它的官网https://spring.io/projects进行详细了解。 Spring 体系中的最最主要的几个项目： SpringFramework SpringData SpringSecurity SpringBoot SpringCloud SpringFramework SpringFramework 这个项目，它是一个开源的 Java/JavaEE 全功能栈的应用程序，SpringFramework 提供了一个简易的开发方式，这种开发方式可以避免使用写可能使底层代码变得繁杂混乱的大量的属性文件和不帮助类。 Spring 的这种低侵入式设计使代码的污染极低。 Data Access/Integration 模块：数据访问/集成 Web 模块：提供了基本的Web开发的集成特性 AOP 模块：提供了面向方面的编程实现，允许您定义多方拦截器和切入点，以干净解耦，实现的功能，应该分开的代码。 Aspects 模块：提供与AspectJ的集成这又是一个功能强大且成熟的面向方面编程（AOP）框架 instrumentation 模块：提供了一定的应用服务器中使用类工具的支持和类加载器实现 messaging 模块：消息通知 Core Container 模块：核心容器 Test 模块：测试模块支持 Spring 组件使用 JUnit 或 TestNG 框架的测试 然后，我们在介绍一下 Spirng 的核心概念：Bean 管理、控制反转、面向切面编程。 Bean 管理 Spring 实现了工厂模式的工厂类，这个类名为 BeanFactory (接口)，在程序中通常用他的子类 ApplicationContext。 Spring 相当于一个大的工厂类，在其配置文件中通过&lt;bean&gt;元素配置用于创建实例对象的类名和实例对象的属性。 工厂模式是一种生产对象型的设计模式，有了工厂模式后，当需要某个类的对象时，就不再需要new指定的类，而是调用工厂中的方法即可。也就不需要关心对象的创建过程。甚至有时候也许你需要的对象只要是某种大分类的类型就可以了，而不必是某个指定的类型。不会过渡依赖某个类，这些类都是易于被替换的，以提高整个项目的可维护性。 控制反转（IOC） Spring 提供了对 IOC 良好支持，IOC 也是一种编程思想，是一种架构艺术，利用这种思想可以很好地实现模块之间的解耦。 IOC 就是对对象的创建、维护、销毁等生命周期的控制，这个过程一般是由我们的程序去主动控制。 DI 也是 IOC 的重要实现。一个对象的创建往往会涉及到其他对象的创建，这就是依赖。 IOC机制既然负责了对象的创建，那么这个依赖关系也就必须由 IOC 容器负责起来。负责的方式就是DI（依赖注入），通过将依赖关系写入配置文件，然后在创建有依赖关系的对象时，由IOC容器注入依赖的对象。如在创建A时，检查到有依赖关系，IOC 容器就把A依赖的对象B创建后注入到A中（组装，通过反射机制实现），然后把A返回给对象请求者，完成工作。 面向切面编程（AOP） Spring 提供了对 AOP 技术的良好封装，AOP 称为面向切面编程，就是系统中有很多各不相干的类的方法，在这些众多方法中要加入某种系统功能的代码，如加入日志，权限判断，异常处理，这种应用称为AOP。 实现 AOP 功能采用的是代理技术，客户端程序不再调用目标，而调用代理类，代理类与目标类对外具有相同的方法声明。 有两种方式可以实现相同的方法声明，一是实现相同的接口，二是作为目标的子类。在 JDK 中采用 Proxy 类，产生动态代理的方式为某个接口生成实现类，如果要为某个类生成子类，则采用 CGLIB。 系统功能的代理以 Advice 对象进行提供，要创建出代理对象，至少需要目标类和 Advice 类。Spring 提供了这种支持，只需要在 Spring 配置文件中配置这两个元素即可实现代理和 AOP 功能。 持续更新中…]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络那些事]]></title>
    <url>%2F2019%2F04%2F16%2F%E7%BD%91%E7%BB%9C%E9%82%A3%E4%BA%9B%E4%BA%8B.html</url>
    <content type="text"><![CDATA[什么 OSI 模型？OSI模型（Open System Interconnection Reference Model，缩写为OSI）,全名“开放式系统互联通信参考模型”，是一个试图使各种计算机在全世界范围内互联为网络的标准框架。 1983年，国际标准组织（ISO）发布了著名的ISO/IEC 7498标准，它定义了网络互联的7层框架，也就是开放式系统互联参考模型。 什么是 OSI 七层模型?建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题。它的最大优点是将服务、接口和协议这三个概念明确地区分开来： 服务说明某一层为上一层提供一些什么功能； 接口说明上一层如何使用下层的服务； 而协议涉及如何实现本层的服务。 这样各层之间具有很强的独立性，互连网络中各实体采用什么样的协议是没有限制的，只要向上提供相同的服务并且不改变相邻层的接口就可以了。 从上到下：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。 应用层：主要是一些终端的应用，比如说 FTP（各种文件下载），WEB（IE浏览），QQ 之类的（你就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用）。 表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）。 传输层：定义了一些传输数据的协议和端口号（WWW 端口 80 等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）。主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。常常把这一层数据叫做段。 网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 数据链路层：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 什么是 TCP/IP 四层模型？TCP/IP 是一组协议的代名词，它还包括许多协议，组成了 TCP/IP 协议簇。TCP/IP 协议簇分为四层，IP 位于协议簇的第二层(对应 OSI 的第三层)，TCP位于协议簇的第三层(对应 OSI 的第四层)。 TCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。TCP/IP 由四个层次组成：应用层、传输层、网络层、网络接口层。 应用层：应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。 传输层：它提供了节点间的数据传送服务，如传输控制协议（TCP）、用户数据报协议（UDP）等，TCP和UDP给数据包加入传输数据并把它传输到下一层中，这一层负责传送数据，并且确定数据已被送达并接收。 网络层：负责提供基本的数据封包传送功能，让每一块数据包都能够到达目的主机（但不检查是否被正确接收），如网际协议（IP）。 网络接口层：负责将数据转换为数字信号在物理设备之间传输。 说说TCP的三次握手？“握手“是为了建立连接，TCP 三次握手的流程图如下： 第一次握手：建立连接时，客户发送 SYN 包[syn=j]到服务器，并进入 SYN_SEND 状态，等待服务器确认； 第二次握手：服务收到 SYN 包，必须确认客户的SYN[ack=j+1]，同时自己也发送一个 SYN 包[syn=k]，即 SYN+ACK 包此时务器进入 SYN_RECV 状态； 第三次握手：客户收到服务的 SYN+ACK 包，向服务器发送确认包ACK[ack=k+1]，包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。 谈谈 TCP 的四次挥手？“挥手“是为了终止连接，TCP 四次挥手的流程图如下： 第一次挥手：Client 发送一个 FIN，用来关团 Client 到 Server 的数据传送，Client 进入 FIN_WAIT_1 状态； 第二次挥手：Server 收到 FIN 后，发送一个 ACK 给 Client，确认序号的收到序号+1（与 SYN 相同，一个 FIN 占用一个序号），Server 进入 CLOSE_WAIT 状态； 第三次挥手：Server 发送一个 FIN．用来关闭 Server 到 Client 的数据传送，Server 进入 LAST_ACK 状态； 第四次挥手：Client 收到 FIN 后，Client 进入 TIME_WAIT 状态，接着发送一个 ACK 给 Server,确认序号为收到序号+1，Server 进入 CLOSED 状态，完成四次挥手。 说说TCP 和 UDP 的区别？TCP 和 UDP 的区别： TCP 是面向连接的，UDP 是面向无连接的 UDP程序结构较简单 TCP 是面向字节流的，UDP 是基于数据报的 TCP 保证数据正确性，UDP 可能丢包 TCP 保证数据顺序，UDP 不保证 TCP 为什么是可靠连接？可靠连接： 通过 TCP 连接传输的数据无差错，不丢失，不重复，且按顺序到达。 TCP 报文头里面的序号能使 TCP 的数据按序到达 报文头里面的确认序号能保证不丢包，累计确认及超时重传机制 TCP 拥有流量控制及拥塞控制的机制 说说你常见 HTTP 状态码？常见HTTP状态码： 200 OK：正常返回信息 400 Bad Request：客户端请求有语法错误，不能被服务器所理解 401 Unauthorized：请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用 403 Forbidden：服务器收到请求，但是拒绝提供服务 404 NotFound：请求资源不存在，eg，输入了错误的URL 500 Internal Server Error：服务器发生不可预期的错误 503 Server Unavailable：服务器当前不能处理客户斕的请求，一段时间后可能恢复正常 GET 请求和 POST 请求的区别？区别： Http 报文层面：GET 将请求信息放在 URL，POST 放在报文体中 数据库层面：CET 符合幕等性和安全性，POST 不符合 其他层面：GET 可以被缓存、被存储，而 POST 不行 Cookie 和 Session 的区别？区别： Cookie 数据存放在客户的浏览器上，Session 数据放在服务器上 Session 对于 Cookie 安全 若考咸轻服务器负担，应当使用Cookie HTTP 与 HTTPS 有什么区别？区别： HTTPS密文传输，HTTP明文传输 连接方式不同，HTTPS默认使用443端口，HTTP使用80端口 HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全 谈谈 CDN 加速原理？CDN 之所以快靠的是多节点、多线路、用缓存； 多节点，也就是多服务器，这样让用户没必要直接向源站请求资源，而是向最近的服务器请求就行了； 多线路，避免了跨线路互联不互通的尴尬； 用缓存，CDN 服务器会从源站拉取资源并缓存到内存中，当用户访问的时候直接从内存中取出来，这样就比从硬盘中去出来快了不少；其次 CDN 服务器知道源站资源发生变化后，会通知其它服务器同时更新资源。 持续更新中…]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
        <tag>UDP</tag>
        <tag>TCP</tag>
        <tag>IP</tag>
      </tags>
  </entry>
</search>
