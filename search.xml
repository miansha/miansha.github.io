<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面向对象那些事]]></title>
    <url>%2F2019%2F06%2F11%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[面向对象呀，不就是继承，封装，多态。下面从这三点展开来讲。 封装什么是封装？将事物拥有的属性和动作隐藏起来，只保留特定的方法与外界联系。 为什么封装？封装符合面向对象设计原则的第一条：单一性原则，一个类把自己该做的事情封装起来，而不是暴露给其他类去处理，当内部的逻辑发生变化时，外部调用不用因此而修改，他们只调用开放的接口，而不用去关心内部的实现。 代码体验123456789101112131415161718192021222324public class Human &#123; private int age; private String name; public int getAge() &#123; return age; &#125; public void setAge(int age) throws Exception &#123; //封装age的检验逻辑，而不是暴露给每个调用者去处理 if (age &gt; 120) &#123; throw new Exception("Invalid value of age"); &#125; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 继承什么是继承？继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。 Java的类可以分为三类： 类：使用class定义，没有抽象方法 抽象类：使用abstract class定义，可以有也可以没有抽象方法 接口：使用inerface定义，只能有抽象方法 在这三个类型之间存在如下关系： 类可以extends：类、抽象类（必须实现所有抽象方法），但只能extends一个，可以implements多个接口（必须实现所有接口方法） 抽象类可以extends：类，抽象类（可全部、部分、或者完全不实现父类抽象方法），可以implements多个接口（可全部、部分、或者完全不实现接口方法） 接口只能extends一个接口 继承以后子类可以得到什么： 子类拥有父类非private的属性和方法 子类可以添加自己的方法和属性，即对父类进行扩展 子类可以重新定义父类的方法，即多态里面的覆盖，后面会详述 关于构造函数： 构造函数不能被继承，子类可以通过super()显示调用父类的构造函数 创建子类时，编译器会自动调用父类的 无参构造函数 如果父类没有定义无参构造函数，子类必须在构造函数的第一行代码使用super()显示调用 类默认拥有无参构造函数，如果定义了其他有参构造函数，则无参函数失效，所以父类没有定义无参构造函数，不是指父类没有写无参构造函数。看下面的例子，父类为Human，子类为Programmer。 为什么需要继承：代码重用是一点，最重要的还是所谓想上转型，即父类的引用变量可以指向子类对象，这是Java面向对象最重要特性多态的基础。 代码体验12345public class Human &#123; //定义了有参构造函数，默认无参构造函数失效 public Human(String name) &#123; &#125;&#125; 12345678public class Programmer extends Human &#123; public Programmer() &#123; //如不显示调用，编译器会出现如下错误 //Implicit super constructor Human() is undefined. //Must explicitly invoke another constructor super("x"); &#125;&#125; 多态在了解多态之前，首先需要知道方法的唯一性标识即什么是相同/不同的方法： 一个方法可以由：修饰符如public、static+返回值+方法名+参数+throw的异常 5部分构成 其中只有方法名和参数是唯一性标识，意即只要方法名和参数相同那他们就是相同的方法 所谓参数相同，是指参数的个数，类型，顺序一致，其中任何一项不同都是不同的方法 何谓重载： 重载是指一个类里面（包括父类的方法）存在方法名相同，但是参数不一样的方法，参数不一样可以是不同的参数个数、类型或顺序 如果仅仅是修饰符、返回值、throw的异常不同，那这是2个相同的方法，编译都通不过，更不要说重载了 代码体验1234567891011121314//重载的例子public class Programmer extends Human &#123; public void coding() throws Exception &#123; &#125; public void coding(String langType) &#123; &#125; public String coding(String langType, String project) &#123; return ""; &#125;&#125; 1234567891011121314//这不是重载，而是三个相同的方法，编译报错public class Programmer extends Human &#123; public void coding() throws Exception &#123; &#125; public void coding() &#123; &#125; public String coding() &#123; return ""; &#125;&#125; 何谓覆盖/重写： 覆盖描述存在继承关系时子类的一种行为 子类中存在和父类相同的方法即为覆盖，何谓相同方法请牢记前面的描述，方法名和参数相同，包括参数个数、类型、顺序 覆盖/重写的规则： 子类不能覆盖父类private的方法，private对子类不可见，如果子类定义了一个和父类private方法相同的方法，实为新增方法 重写方法的修饰符一定要大于被重写方法的修饰符(public &gt; protected &gt; default &gt; private) 重写抛出的异常需与父类相同或是父类异常的子类，或者重写方法干脆不写throws 重写方法的返回值必须与被重写方法一致，否则编译报错 静态方法不能被重写为非静态方法，否则编译出错 理解了上述知识点，是时候定义多态了： 多态可以说是“一个接口，多种实现”或者说是父类的引用变量可以指向子类的实例，被引用对象的类型决定调用谁的方法，但这个方法必须在父类中定义 多态可以分为两种类型：编译时多态（方法的重载）和运行时多态（继承时方法的重写），编译时多态很好理解，后述内容针对运行时多态 运行时多态依赖于继承、重写和向上转型 1234567891011121314151617181920212223242526272829303132333435363738394041class Human &#123; public void showName() &#123; System.out.println("I am Human"); &#125;&#125;//继承关系class Doctor extends Human &#123; //方法重写 public void showName() &#123; System.out.println("I am Doctor"); &#125;&#125;class Programmer extends Human &#123; public void showName() &#123; System.out.println("I am Programmer"); &#125;&#125;public class Test &#123; //向上转型 public Human humanFactory(String humanType) &#123; if ("doctor".equals(humanType)) &#123; return new Doctor(); &#125; if ("programmer".equals(humanType)) &#123; return new Programmer(); &#125; return new Human(); &#125; public static void main(String args[]) &#123; Test test = new Test(); Human human = test.humanFactory("doctor"); human.showName();//Output:I am Doctor human = test.humanFactory("programmer"); human.showName();//Output:I am Programmer //一个接口的方法，表现出不同的形态，意即为多态也 &#125;&#125; 向上转型的缺憾： 只能调用父类中定义的属性和方法，对于子类中的方法和属性它就望尘莫及了，必须强转成子类类型 总结概括： 当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
</search>
